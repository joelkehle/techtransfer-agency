package priorartsearch

import "time"

const Disclaimer = "DISCLAIMER: This is an automated preliminary prior art search generated by\n" +
	"an AI system. It is NOT a substitute for a professional patentability\n" +
	"search or freedom-to-operate analysis conducted by a qualified patent\n" +
	"attorney or search firm. This search covers only granted U.S. patents in\n" +
	"the USPTO PatentsView database. It does not cover pre-grant publications,\n" +
	"foreign patents, non-patent literature, trade publications, or unpublished\n" +
	"applications. The absence of relevant results does not mean no prior art\n" +
	"exists. Any patenting decision should be made in consultation with patent\n" +
	"counsel."

const (
	CapabilityPriorArtSearch  = "prior-art-search"
	AgentVersion              = "3.2.0"
	MinDisclosureChars        = 100
	MaxDisclosureChars        = 100000
	DefaultLLMModel           = "claude-sonnet-4-20250514"
	DefaultMaxPatents         = 300
	DefaultMaxAssess          = 75
	DefaultBatchSize          = 15
	DefaultRateLimitPerMinute = 40
	PatentsViewBaseURL        = "https://search.patentsview.org"
	PatentsViewPatentPath     = "/api/v1/patent/"
)

type Determination string

const (
	DeterminationClearField   Determination = "CLEAR_FIELD"
	DeterminationCrowdedField Determination = "CROWDED_FIELD"
	DeterminationBlockingArt  Determination = "BLOCKING_ART_FOUND"
	DeterminationInconclusive Determination = "INCONCLUSIVE"
)

type Relevance string

const (
	RelevanceHigh   Relevance = "HIGH"
	RelevanceMedium Relevance = "MEDIUM"
	RelevanceLow    Relevance = "LOW"
	RelevanceNone   Relevance = "NONE"
)

type LandscapeDensity string

const (
	DensitySparse   LandscapeDensity = "SPARSE"
	DensityModerate LandscapeDensity = "MODERATE"
	DensityDense    LandscapeDensity = "DENSE"
)

type BlockingRiskLevel string

const (
	BlockingRiskHigh   BlockingRiskLevel = "HIGH"
	BlockingRiskMedium BlockingRiskLevel = "MEDIUM"
	BlockingRiskLow    BlockingRiskLevel = "LOW"
	BlockingRiskNone   BlockingRiskLevel = "NONE"
)

type DesignAroundLevel string

const (
	DesignAroundEasy      DesignAroundLevel = "EASY"
	DesignAroundModerate  DesignAroundLevel = "MODERATE"
	DesignAroundDifficult DesignAroundLevel = "DIFFICULT"
)

type StrategyPriority string

const (
	PriorityPrimary   StrategyPriority = "PRIMARY"
	PrioritySecondary StrategyPriority = "SECONDARY"
	PriorityTertiary  StrategyPriority = "TERTIARY"
)

type RequestMetadata struct {
	SourceFilename   string `json:"source_filename,omitempty"`
	ExtractionMethod string `json:"extraction_method,omitempty"`
	Truncated        bool   `json:"truncated,omitempty"`
}

type Stage6PriorOutput struct {
	NoveltyConcerns        []string `json:"novelty_concerns"`
	NonObviousnessConcerns []string `json:"non_obviousness_concerns"`
	PriorArtSearchPriority string   `json:"prior_art_search_priority"`
	Reasoning              string   `json:"reasoning"`
}

type Stage1PriorOutput struct {
	InventionTitle       string   `json:"invention_title"`
	TechnologyArea       string   `json:"technology_area"`
	NovelElements        []string `json:"novel_elements"`
	InventionDescription string   `json:"invention_description"`
}

type PriorContext struct {
	Stage6Output *Stage6PriorOutput `json:"stage6_output,omitempty"`
	Stage1Output *Stage1PriorOutput `json:"stage1_output,omitempty"`
}

type RequestEnvelope struct {
	CaseID         string          `json:"case_id"`
	DisclosureText string          `json:"disclosure_text"`
	Metadata       RequestMetadata `json:"metadata,omitempty"`
	PriorContext   *PriorContext   `json:"prior_context,omitempty"`
}

type Stage1NovelElement struct {
	ID          string `json:"id"`
	Description string `json:"description"`
}

type TermFamily struct {
	Canonical      string   `json:"canonical"`
	Synonyms       []string `json:"synonyms"`
	Acronyms       []string `json:"acronyms"`
	PatentVariants []string `json:"patent_variants"`
}

type QueryStrategy struct {
	ID            string           `json:"id"`
	Description   string           `json:"description"`
	TermFamilies  []TermFamily     `json:"term_families"`
	Phrases       []string         `json:"phrases"`
	CPCSubclasses []string         `json:"cpc_subclasses"`
	Priority      StrategyPriority `json:"priority"`
}

type Stage1Output struct {
	InventionTitle    string               `json:"invention_title"`
	InventionSummary  string               `json:"invention_summary"`
	NovelElements     []Stage1NovelElement `json:"novel_elements"`
	TechnologyDomains []string             `json:"technology_domains"`
	QueryStrategies   []QueryStrategy      `json:"query_strategies"`
	ConfidenceScore   float64              `json:"confidence_score"`
	ConfidenceReason  string               `json:"confidence_reason"`
}

type PatentResult struct {
	PatentID       string   `json:"patent_id"`
	Title          string   `json:"patent_title"`
	Abstract       string   `json:"patent_abstract"`
	GrantDate      string   `json:"patent_date"`
	FilingDate     *string  `json:"filing_date"`
	Assignees      []string `json:"assignees"`
	CPCSubclasses  []string `json:"cpc_subclasses"`
	Inventors      []string `json:"inventors"`
	MatchedQueries []string `json:"matched_queries"`
	StrategyCount  int      `json:"strategy_count"`
}

type Stage2Output struct {
	Patents          []PatentResult `json:"patents"`
	QueriesExecuted  int            `json:"queries_executed"`
	QueriesFailed    int            `json:"queries_failed"`
	QueriesSkipped   int            `json:"queries_skipped"`
	TotalAPICalls    int            `json:"total_api_calls"`
	TotalHitsByQuery map[string]int `json:"total_hits_by_query"`
}

type PatentAssessment struct {
	PatentID             string    `json:"patent_id"`
	Relevance            Relevance `json:"relevance"`
	OverlapDescription   string    `json:"overlap_description"`
	NovelElementsCovered []string  `json:"novel_elements_covered"`
	ConfidenceScore      float64   `json:"confidence_score"`
}

type Stage3Output struct {
	Assessments []PatentAssessment `json:"assessments"`
}

type AssigneeCount struct {
	Name  string `json:"name"`
	Count int    `json:"count"`
}

type CPCCount struct {
	Subclass string `json:"subclass"`
	Count    int    `json:"count"`
}

type NovelElementCoverage struct {
	ID          string `json:"id"`
	Description string `json:"description"`
	HighCount   int    `json:"high_count"`
	MediumCount int    `json:"medium_count"`
	TotalCount  int    `json:"total_count"`
}

type KeyPlayer struct {
	Name          string `json:"name"`
	RelevanceNote string `json:"relevance_note"`
	PatentCount   int    `json:"patent_count"`
}

type BlockingRisk struct {
	Level           BlockingRiskLevel `json:"level"`
	BlockingPatents []string          `json:"blocking_patents"`
	Reasoning       string            `json:"reasoning"`
}

type DesignAroundPotential struct {
	Level     DesignAroundLevel `json:"level"`
	Reasoning string            `json:"reasoning"`
}

type Stage4Output struct {
	LandscapeDensity          LandscapeDensity      `json:"landscape_density"`
	LandscapeDensityReasoning string                `json:"landscape_density_reasoning"`
	KeyPlayers                []KeyPlayer           `json:"key_players"`
	BlockingRisk              BlockingRisk          `json:"blocking_risk"`
	DesignAroundPotential     DesignAroundPotential `json:"design_around_potential"`
	WhiteSpace                []string              `json:"white_space"`
	Determination             Determination         `json:"determination"`
	DeterminationReasoning    string                `json:"determination_reasoning"`
	ConfidenceScore           float64               `json:"confidence_score"`
	ConfidenceReason          string                `json:"confidence_reason"`
}

type StructuredResults struct {
	SearchStrategy Stage1Output       `json:"search_strategy"`
	PatentsFound   Stage2Output       `json:"patents_found"`
	Assessments    []PatentAssessment `json:"assessments"`
	Landscape      *Stage4Output      `json:"landscape"`
}

type PipelineMetadata struct {
	StagesExecuted        []string  `json:"stages_executed"`
	StagesFailed          []string  `json:"stages_failed"`
	Degraded              bool      `json:"degraded"`
	DegradedReason        *string   `json:"degraded_reason"`
	TotalPatentsRetrieved int       `json:"total_patents_retrieved"`
	TotalPatentsAssessed  int       `json:"total_patents_assessed"`
	AbstractsMissing      int       `json:"abstracts_missing"`
	AssessedNone          int       `json:"assessed_none"`
	AssessmentTruncated   bool      `json:"assessment_truncated"`
	APICallsMade          int       `json:"api_calls_made"`
	DurationMS            int64     `json:"duration_ms"`
	Model                 string    `json:"model"`
	Temperature           float64   `json:"temperature"`
	InputTruncated        bool      `json:"input_truncated"`
	StartedAt             time.Time `json:"started_at,omitempty"`
	CompletedAt           time.Time `json:"completed_at,omitempty"`
}

type ResponseEnvelope struct {
	CaseID            string            `json:"case_id"`
	Agent             string            `json:"agent"`
	Version           string            `json:"version"`
	Determination     Determination     `json:"determination"`
	ReportMarkdown    string            `json:"report_markdown"`
	StructuredResults StructuredResults `json:"structured_results"`
	Metadata          PipelineMetadata  `json:"metadata"`
}

type StageAttemptMetrics struct {
	Attempts       int
	ContentRetries int
}

type PipelineResult struct {
	Request           RequestEnvelope
	Stage1            Stage1Output
	Stage2            Stage2Output
	Stage3            *Stage3Output
	Stage4            *Stage4Output
	Determination     Determination
	ReportMarkdown    string
	Metadata          PipelineMetadata
	Attempts          map[string]StageAttemptMetrics
	AssigneeFrequency []AssigneeCount
	CPCHistogram      []CPCCount
	NovelCoverage     []NovelElementCoverage
}

type StageError struct {
	Stage string
	Err   error
}

func (e *StageError) Error() string { return e.Stage + ": " + e.Err.Error() }
func (e *StageError) Unwrap() error { return e.Err }

var stopwords = map[string]struct{}{
	"system": {}, "method": {}, "apparatus": {}, "device": {}, "process": {},
	"using": {}, "based": {}, "for": {}, "and": {}, "the": {}, "of": {},
	"via": {}, "includes": {}, "comprising": {}, "network": {}, "means": {},
	"said": {}, "wherein": {}, "thereof": {}, "therein": {}, "step": {}, "steps": {},
}
